# Clean code

## Имена переменных
Внесите 15 правок в свой код с учётом рекомендаций из данного занятия, и напишите по каждой, как и что конкретно вы улучшили.

Если мы говорим про использования в коде переменных так, чтобы обращения к ней было желательно в одном месте, то в реакт, когда мы создаем компонент, и хотим использовать внутренний стейт, то используем хуки, и обычно это условно глобальная переменная для этого компонента, и она изменяется в рандомных местах компонента. Для решения этой проблемы, кажется, что нужно просто делать их не очень большого размера, хотя иногда это довольно сложно.

Получается, что и область видимости нельзя уменьшить до уровня метода компонента, хотя и можно вызывать хук, брать данные из него рядом с кодом, где он будет примене.

1.
```
 const [activeTab, setActiveTab] = useState('')

 затем сеттер используется по всему коду, и иногда отследить его поведение реально сложно, ибо срабатывает реактивность, таких примеров будет много
```
2. 
```
const [pickerValue, setPickerValue] = useState<Dayjs | null>()
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
3. 
```
const [tags, setTags] = useState<string[]>([])
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
4. 
```
const [state, setState] = useState<TTagsState>({})
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
5. 
```
const [visibleEdit, setVisibleEdit] = useState(false)
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
6. 
```
const [isLoading, setIsLoading] = useState(true)
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
7. 
```
const [isLoading, setIsLoading] = useState(true)
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
8. 
```
const [renewed, setRenewed] = useState(false)
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
9. 
```
const [isOpen, setIsOpen] = useState(false)
с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
10.
```
 const [showSuccess, setShowSuccess] = useState<boolean>(false)
 с этой реализацие не возможно уменьшить область видимости, по этому нужно использовать это грамотно, и обьявлять не как подключаемый модуль вверху кода, а перед тем местом, где используется функция, с геттером проще, мы просто извлекаем данные из него и выводи, это место править н надо
```
11.
```
const format = (date: number, type: string): string => form(date, type, { locale: ruLocale })

export function formatDate(date: string): string {
  const splittedDate = date.split('-')
  const newDate = new Date().setFullYear(+splittedDate[0], +splittedDate[1] - 1, +splittedDate[2])
  if (isToday(newDate)) return 'Сегодня'
  if (isYesterday(newDate)) return 'Вчера'
  if (isThisYear(newDate)) return `${format(newDate, DATE_FORMAT['d MMMM'])}`
  return format(newDate, DATE_FORMAT['d MMMM yyyy'])
}

я бы const format обьявил внутри formDate, а то замыкание технически, можно и потерять по дороге, да и наглядней будет, а лучше, как аргумент функции formatDate
```
12.
 ```
const dateFormat = DATE_FORMAT['yyyy-MM-dd']

const dateFilterReducer = (state: DateFilterState, action: DateFilterAction): DateFilterState => {
  const { all, yesterday, currentMonth, lastMonth, custom } = FILTER_DATE_PERIOD
  switch (action.type) {
    case all.type:
      return initialDateFilterState
    case yesterday.type:
      return {
        startDate: getYesterday(dateFormat),
        endDate: getYesterday(dateFormat),
      }

      здесь я бы добавил dateFormat в аргументы функции dateFilterReducer
```
13.
 ```
const [isLoading, ToggleLoading] = useToggle(true)
...много кода и потом используется
```
14.
 ```
 const [paymentStatus, setPaymentStatus] = useState
 ...много кода и потом используется
```
15.
 ```
const [isOpen, setIsOpen] = useState(false)
...много кода и потом используется
```